// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/TylerGrey/ent-shop/db/ent/category"
	"github.com/TylerGrey/ent-shop/db/ent/delivery"
	"github.com/TylerGrey/ent-shop/db/ent/item"
	"github.com/TylerGrey/ent-shop/db/ent/member"
	"github.com/TylerGrey/ent-shop/db/ent/order"
	"github.com/TylerGrey/ent-shop/db/ent/orderitem"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory  = "Category"
	TypeDelivery  = "Delivery"
	TypeItem      = "Item"
	TypeMember    = "Member"
	TypeOrder     = "Order"
	TypeOrderItem = "OrderItem"
)

// CategoryMutation represents an operation that mutate the Categories
// nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	clearedFields   map[string]struct{}
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	items           map[int]struct{}
	removeditems    map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Category, error)
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows to manage the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for $n.Name.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the id field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Category.
// If the Category object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Category.
// If the Category object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Category.
// If the Category object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetParentID sets the parent edge to Category by id.
func (m *CategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the parent edge to Category.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *CategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the children edge to Category by ids.
func (m *CategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// RemoveChildIDs removes the children edge to Category by ids.
func (m *CategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed ids of children.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the children ids in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren reset all changes of the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.removedchildren = nil
}

// AddItemIDs adds the items edge to Item by ids.
func (m *CategoryMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// RemoveItemIDs removes the items edge to Item by ids.
func (m *CategoryMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed ids of items.
func (m *CategoryMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the items ids in the mutation.
func (m *CategoryMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems reset all changes of the "items" edge.
func (m *CategoryMutation) ResetItems() {
	m.items = nil
	m.removeditems = nil
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.items != nil {
		edges = append(edges, category.EdgeItems)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.removeditems != nil {
		edges = append(edges, category.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	case category.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// DeliveryMutation represents an operation that mutate the Deliveries
// nodes in the graph.
type DeliveryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	city          *string
	street        *string
	zipcode       *string
	created_at    *time.Time
	updated_at    *time.Time
	status        *delivery.Status
	clearedFields map[string]struct{}
	order         *int
	clearedorder  bool
	done          bool
	oldValue      func(context.Context) (*Delivery, error)
}

var _ ent.Mutation = (*DeliveryMutation)(nil)

// deliveryOption allows to manage the mutation configuration using functional options.
type deliveryOption func(*DeliveryMutation)

// newDeliveryMutation creates new mutation for $n.Name.
func newDeliveryMutation(c config, op Op, opts ...deliveryOption) *DeliveryMutation {
	m := &DeliveryMutation{
		config:        c,
		op:            op,
		typ:           TypeDelivery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryID sets the id field of the mutation.
func withDeliveryID(id int) deliveryOption {
	return func(m *DeliveryMutation) {
		var (
			err   error
			once  sync.Once
			value *Delivery
		)
		m.oldValue = func(ctx context.Context) (*Delivery, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Delivery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDelivery sets the old Delivery of the mutation.
func withDelivery(node *Delivery) deliveryOption {
	return func(m *DeliveryMutation) {
		m.oldValue = func(context.Context) (*Delivery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DeliveryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCity sets the city field.
func (m *DeliveryMutation) SetCity(s string) {
	m.city = &s
}

// City returns the city value in the mutation.
func (m *DeliveryMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old city value of the Delivery.
// If the Delivery object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeliveryMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of city.
func (m *DeliveryMutation) ClearCity() {
	m.city = nil
	m.clearedFields[delivery.FieldCity] = struct{}{}
}

// CityCleared returns if the field city was cleared in this mutation.
func (m *DeliveryMutation) CityCleared() bool {
	_, ok := m.clearedFields[delivery.FieldCity]
	return ok
}

// ResetCity reset all changes of the "city" field.
func (m *DeliveryMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, delivery.FieldCity)
}

// SetStreet sets the street field.
func (m *DeliveryMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the street value in the mutation.
func (m *DeliveryMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old street value of the Delivery.
// If the Delivery object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeliveryMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStreet is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of street.
func (m *DeliveryMutation) ClearStreet() {
	m.street = nil
	m.clearedFields[delivery.FieldStreet] = struct{}{}
}

// StreetCleared returns if the field street was cleared in this mutation.
func (m *DeliveryMutation) StreetCleared() bool {
	_, ok := m.clearedFields[delivery.FieldStreet]
	return ok
}

// ResetStreet reset all changes of the "street" field.
func (m *DeliveryMutation) ResetStreet() {
	m.street = nil
	delete(m.clearedFields, delivery.FieldStreet)
}

// SetZipcode sets the zipcode field.
func (m *DeliveryMutation) SetZipcode(s string) {
	m.zipcode = &s
}

// Zipcode returns the zipcode value in the mutation.
func (m *DeliveryMutation) Zipcode() (r string, exists bool) {
	v := m.zipcode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipcode returns the old zipcode value of the Delivery.
// If the Delivery object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeliveryMutation) OldZipcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZipcode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZipcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipcode: %w", err)
	}
	return oldValue.Zipcode, nil
}

// ClearZipcode clears the value of zipcode.
func (m *DeliveryMutation) ClearZipcode() {
	m.zipcode = nil
	m.clearedFields[delivery.FieldZipcode] = struct{}{}
}

// ZipcodeCleared returns if the field zipcode was cleared in this mutation.
func (m *DeliveryMutation) ZipcodeCleared() bool {
	_, ok := m.clearedFields[delivery.FieldZipcode]
	return ok
}

// ResetZipcode reset all changes of the "zipcode" field.
func (m *DeliveryMutation) ResetZipcode() {
	m.zipcode = nil
	delete(m.clearedFields, delivery.FieldZipcode)
}

// SetCreatedAt sets the created_at field.
func (m *DeliveryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *DeliveryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Delivery.
// If the Delivery object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeliveryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *DeliveryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *DeliveryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *DeliveryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Delivery.
// If the Delivery object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeliveryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *DeliveryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the status field.
func (m *DeliveryMutation) SetStatus(d delivery.Status) {
	m.status = &d
}

// Status returns the status value in the mutation.
func (m *DeliveryMutation) Status() (r delivery.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Delivery.
// If the Delivery object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeliveryMutation) OldStatus(ctx context.Context) (v delivery.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *DeliveryMutation) ResetStatus() {
	m.status = nil
}

// SetOrderID sets the order edge to Order by id.
func (m *DeliveryMutation) SetOrderID(id int) {
	m.order = &id
}

// ClearOrder clears the order edge to Order.
func (m *DeliveryMutation) ClearOrder() {
	m.clearedorder = true
}

// OrderCleared returns if the edge order was cleared.
func (m *DeliveryMutation) OrderCleared() bool {
	return m.clearedorder
}

// OrderID returns the order id in the mutation.
func (m *DeliveryMutation) OrderID() (id int, exists bool) {
	if m.order != nil {
		return *m.order, true
	}
	return
}

// OrderIDs returns the order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *DeliveryMutation) OrderIDs() (ids []int) {
	if id := m.order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder reset all changes of the "order" edge.
func (m *DeliveryMutation) ResetOrder() {
	m.order = nil
	m.clearedorder = false
}

// Op returns the operation name.
func (m *DeliveryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Delivery).
func (m *DeliveryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DeliveryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.city != nil {
		fields = append(fields, delivery.FieldCity)
	}
	if m.street != nil {
		fields = append(fields, delivery.FieldStreet)
	}
	if m.zipcode != nil {
		fields = append(fields, delivery.FieldZipcode)
	}
	if m.created_at != nil {
		fields = append(fields, delivery.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, delivery.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, delivery.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DeliveryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case delivery.FieldCity:
		return m.City()
	case delivery.FieldStreet:
		return m.Street()
	case delivery.FieldZipcode:
		return m.Zipcode()
	case delivery.FieldCreatedAt:
		return m.CreatedAt()
	case delivery.FieldUpdatedAt:
		return m.UpdatedAt()
	case delivery.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DeliveryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case delivery.FieldCity:
		return m.OldCity(ctx)
	case delivery.FieldStreet:
		return m.OldStreet(ctx)
	case delivery.FieldZipcode:
		return m.OldZipcode(ctx)
	case delivery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case delivery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case delivery.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Delivery field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeliveryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case delivery.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case delivery.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case delivery.FieldZipcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipcode(v)
		return nil
	case delivery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case delivery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case delivery.FieldStatus:
		v, ok := value.(delivery.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Delivery field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DeliveryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DeliveryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeliveryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Delivery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DeliveryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(delivery.FieldCity) {
		fields = append(fields, delivery.FieldCity)
	}
	if m.FieldCleared(delivery.FieldStreet) {
		fields = append(fields, delivery.FieldStreet)
	}
	if m.FieldCleared(delivery.FieldZipcode) {
		fields = append(fields, delivery.FieldZipcode)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DeliveryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryMutation) ClearField(name string) error {
	switch name {
	case delivery.FieldCity:
		m.ClearCity()
		return nil
	case delivery.FieldStreet:
		m.ClearStreet()
		return nil
	case delivery.FieldZipcode:
		m.ClearZipcode()
		return nil
	}
	return fmt.Errorf("unknown Delivery nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DeliveryMutation) ResetField(name string) error {
	switch name {
	case delivery.FieldCity:
		m.ResetCity()
		return nil
	case delivery.FieldStreet:
		m.ResetStreet()
		return nil
	case delivery.FieldZipcode:
		m.ResetZipcode()
		return nil
	case delivery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case delivery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case delivery.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Delivery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DeliveryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order != nil {
		edges = append(edges, delivery.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DeliveryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case delivery.EdgeOrder:
		if id := m.order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DeliveryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DeliveryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DeliveryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder {
		edges = append(edges, delivery.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DeliveryMutation) EdgeCleared(name string) bool {
	switch name {
	case delivery.EdgeOrder:
		return m.clearedorder
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DeliveryMutation) ClearEdge(name string) error {
	switch name {
	case delivery.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown Delivery unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DeliveryMutation) ResetEdge(name string) error {
	switch name {
	case delivery.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Delivery edge %s", name)
}

// ItemMutation represents an operation that mutate the Items
// nodes in the graph.
type ItemMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	price             *int32
	addprice          *int32
	stockQuantity     *int32
	addstockQuantity  *int32
	dtype             *item.Dtype
	clearedFields     map[string]struct{}
	categories        map[int]struct{}
	removedcategories map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Item, error)
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows to manage the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for $n.Name.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the id field of the mutation.
func withItemID(id int) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Item.
// If the Item object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Item.
// If the Item object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *ItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Item.
// If the Item object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ItemMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the price field.
func (m *ItemMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *ItemMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Item.
// If the Item object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ItemMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to price.
func (m *ItemMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *ItemMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *ItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetStockQuantity sets the stockQuantity field.
func (m *ItemMutation) SetStockQuantity(i int32) {
	m.stockQuantity = &i
	m.addstockQuantity = nil
}

// StockQuantity returns the stockQuantity value in the mutation.
func (m *ItemMutation) StockQuantity() (r int32, exists bool) {
	v := m.stockQuantity
	if v == nil {
		return
	}
	return *v, true
}

// OldStockQuantity returns the old stockQuantity value of the Item.
// If the Item object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ItemMutation) OldStockQuantity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStockQuantity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStockQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockQuantity: %w", err)
	}
	return oldValue.StockQuantity, nil
}

// AddStockQuantity adds i to stockQuantity.
func (m *ItemMutation) AddStockQuantity(i int32) {
	if m.addstockQuantity != nil {
		*m.addstockQuantity += i
	} else {
		m.addstockQuantity = &i
	}
}

// AddedStockQuantity returns the value that was added to the stockQuantity field in this mutation.
func (m *ItemMutation) AddedStockQuantity() (r int32, exists bool) {
	v := m.addstockQuantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetStockQuantity reset all changes of the "stockQuantity" field.
func (m *ItemMutation) ResetStockQuantity() {
	m.stockQuantity = nil
	m.addstockQuantity = nil
}

// SetDtype sets the dtype field.
func (m *ItemMutation) SetDtype(i item.Dtype) {
	m.dtype = &i
}

// Dtype returns the dtype value in the mutation.
func (m *ItemMutation) Dtype() (r item.Dtype, exists bool) {
	v := m.dtype
	if v == nil {
		return
	}
	return *v, true
}

// OldDtype returns the old dtype value of the Item.
// If the Item object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ItemMutation) OldDtype(ctx context.Context) (v item.Dtype, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDtype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDtype: %w", err)
	}
	return oldValue.Dtype, nil
}

// ResetDtype reset all changes of the "dtype" field.
func (m *ItemMutation) ResetDtype() {
	m.dtype = nil
}

// AddCategoryIDs adds the categories edge to Category by ids.
func (m *ItemMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// RemoveCategoryIDs removes the categories edge to Category by ids.
func (m *ItemMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed ids of categories.
func (m *ItemMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the categories ids in the mutation.
func (m *ItemMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories reset all changes of the "categories" edge.
func (m *ItemMutation) ResetCategories() {
	m.categories = nil
	m.removedcategories = nil
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, item.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, item.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, item.FieldName)
	}
	if m.price != nil {
		fields = append(fields, item.FieldPrice)
	}
	if m.stockQuantity != nil {
		fields = append(fields, item.FieldStockQuantity)
	}
	if m.dtype != nil {
		fields = append(fields, item.FieldDtype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldCreatedAt:
		return m.CreatedAt()
	case item.FieldUpdatedAt:
		return m.UpdatedAt()
	case item.FieldName:
		return m.Name()
	case item.FieldPrice:
		return m.Price()
	case item.FieldStockQuantity:
		return m.StockQuantity()
	case item.FieldDtype:
		return m.Dtype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case item.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case item.FieldName:
		return m.OldName(ctx)
	case item.FieldPrice:
		return m.OldPrice(ctx)
	case item.FieldStockQuantity:
		return m.OldStockQuantity(ctx)
	case item.FieldDtype:
		return m.OldDtype(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case item.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case item.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case item.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case item.FieldStockQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockQuantity(v)
		return nil
	case item.FieldDtype:
		v, ok := value.(item.Dtype)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDtype(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, item.FieldPrice)
	}
	if m.addstockQuantity != nil {
		fields = append(fields, item.FieldStockQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case item.FieldPrice:
		return m.AddedPrice()
	case item.FieldStockQuantity:
		return m.AddedStockQuantity()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case item.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case item.FieldStockQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case item.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case item.FieldName:
		m.ResetName()
		return nil
	case item.FieldPrice:
		m.ResetPrice()
		return nil
	case item.FieldStockQuantity:
		m.ResetStockQuantity()
		return nil
	case item.FieldDtype:
		m.ResetDtype()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.categories != nil {
		edges = append(edges, item.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcategories != nil {
		edges = append(edges, item.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// MemberMutation represents an operation that mutate the Members
// nodes in the graph.
type MemberMutation struct {
	config
	op            Op
	typ           string
	id            *int
	city          *string
	street        *string
	zipcode       *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	clearedFields map[string]struct{}
	orders        map[int]struct{}
	removedorders map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Member, error)
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows to manage the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for $n.Name.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the id field of the mutation.
func withMemberID(id int) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCity sets the city field.
func (m *MemberMutation) SetCity(s string) {
	m.city = &s
}

// City returns the city value in the mutation.
func (m *MemberMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old city value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of city.
func (m *MemberMutation) ClearCity() {
	m.city = nil
	m.clearedFields[member.FieldCity] = struct{}{}
}

// CityCleared returns if the field city was cleared in this mutation.
func (m *MemberMutation) CityCleared() bool {
	_, ok := m.clearedFields[member.FieldCity]
	return ok
}

// ResetCity reset all changes of the "city" field.
func (m *MemberMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, member.FieldCity)
}

// SetStreet sets the street field.
func (m *MemberMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the street value in the mutation.
func (m *MemberMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old street value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStreet is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of street.
func (m *MemberMutation) ClearStreet() {
	m.street = nil
	m.clearedFields[member.FieldStreet] = struct{}{}
}

// StreetCleared returns if the field street was cleared in this mutation.
func (m *MemberMutation) StreetCleared() bool {
	_, ok := m.clearedFields[member.FieldStreet]
	return ok
}

// ResetStreet reset all changes of the "street" field.
func (m *MemberMutation) ResetStreet() {
	m.street = nil
	delete(m.clearedFields, member.FieldStreet)
}

// SetZipcode sets the zipcode field.
func (m *MemberMutation) SetZipcode(s string) {
	m.zipcode = &s
}

// Zipcode returns the zipcode value in the mutation.
func (m *MemberMutation) Zipcode() (r string, exists bool) {
	v := m.zipcode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipcode returns the old zipcode value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldZipcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZipcode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZipcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipcode: %w", err)
	}
	return oldValue.Zipcode, nil
}

// ClearZipcode clears the value of zipcode.
func (m *MemberMutation) ClearZipcode() {
	m.zipcode = nil
	m.clearedFields[member.FieldZipcode] = struct{}{}
}

// ZipcodeCleared returns if the field zipcode was cleared in this mutation.
func (m *MemberMutation) ZipcodeCleared() bool {
	_, ok := m.clearedFields[member.FieldZipcode]
	return ok
}

// ResetZipcode reset all changes of the "zipcode" field.
func (m *MemberMutation) ResetZipcode() {
	m.zipcode = nil
	delete(m.clearedFields, member.FieldZipcode)
}

// SetCreatedAt sets the created_at field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *MemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Member.
// If the Member object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MemberMutation) ResetName() {
	m.name = nil
}

// AddOrderIDs adds the orders edge to Order by ids.
func (m *MemberMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// RemoveOrderIDs removes the orders edge to Order by ids.
func (m *MemberMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed ids of orders.
func (m *MemberMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the orders ids in the mutation.
func (m *MemberMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders reset all changes of the "orders" edge.
func (m *MemberMutation) ResetOrders() {
	m.orders = nil
	m.removedorders = nil
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.city != nil {
		fields = append(fields, member.FieldCity)
	}
	if m.street != nil {
		fields = append(fields, member.FieldStreet)
	}
	if m.zipcode != nil {
		fields = append(fields, member.FieldZipcode)
	}
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, member.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCity:
		return m.City()
	case member.FieldStreet:
		return m.Street()
	case member.FieldZipcode:
		return m.Zipcode()
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCity:
		return m.OldCity(ctx)
	case member.FieldStreet:
		return m.OldStreet(ctx)
	case member.FieldZipcode:
		return m.OldZipcode(ctx)
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case member.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case member.FieldZipcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipcode(v)
		return nil
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldCity) {
		fields = append(fields, member.FieldCity)
	}
	if m.FieldCleared(member.FieldStreet) {
		fields = append(fields, member.FieldStreet)
	}
	if m.FieldCleared(member.FieldZipcode) {
		fields = append(fields, member.FieldZipcode)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldCity:
		m.ClearCity()
		return nil
	case member.FieldStreet:
		m.ClearStreet()
		return nil
	case member.FieldZipcode:
		m.ClearZipcode()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCity:
		m.ResetCity()
		return nil
	case member.FieldStreet:
		m.ResetStreet()
		return nil
	case member.FieldZipcode:
		m.ResetZipcode()
		return nil
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.orders != nil {
		edges = append(edges, member.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorders != nil {
		edges = append(edges, member.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// OrderMutation represents an operation that mutate the Orders
// nodes in the graph.
type OrderMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	orderDate         *time.Time
	status            *order.Status
	clearedFields     map[string]struct{}
	orderItems        map[int]struct{}
	removedorderItems map[int]struct{}
	delivery          *int
	cleareddelivery   bool
	done              bool
	oldValue          func(context.Context) (*Order, error)
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows to manage the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for $n.Name.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the id field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderDate sets the orderDate field.
func (m *OrderMutation) SetOrderDate(t time.Time) {
	m.orderDate = &t
}

// OrderDate returns the orderDate value in the mutation.
func (m *OrderMutation) OrderDate() (r time.Time, exists bool) {
	v := m.orderDate
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDate returns the old orderDate value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDate: %w", err)
	}
	return oldValue.OrderDate, nil
}

// ResetOrderDate reset all changes of the "orderDate" field.
func (m *OrderMutation) ResetOrderDate() {
	m.orderDate = nil
}

// SetStatus sets the status field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the status value in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// AddOrderItemIDs adds the orderItems edge to OrderItem by ids.
func (m *OrderMutation) AddOrderItemIDs(ids ...int) {
	if m.orderItems == nil {
		m.orderItems = make(map[int]struct{})
	}
	for i := range ids {
		m.orderItems[ids[i]] = struct{}{}
	}
}

// RemoveOrderItemIDs removes the orderItems edge to OrderItem by ids.
func (m *OrderMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorderItems == nil {
		m.removedorderItems = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorderItems[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed ids of orderItems.
func (m *OrderMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorderItems {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the orderItems ids in the mutation.
func (m *OrderMutation) OrderItemsIDs() (ids []int) {
	for id := range m.orderItems {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems reset all changes of the "orderItems" edge.
func (m *OrderMutation) ResetOrderItems() {
	m.orderItems = nil
	m.removedorderItems = nil
}

// SetDeliveryID sets the delivery edge to Delivery by id.
func (m *OrderMutation) SetDeliveryID(id int) {
	m.delivery = &id
}

// ClearDelivery clears the delivery edge to Delivery.
func (m *OrderMutation) ClearDelivery() {
	m.cleareddelivery = true
}

// DeliveryCleared returns if the edge delivery was cleared.
func (m *OrderMutation) DeliveryCleared() bool {
	return m.cleareddelivery
}

// DeliveryID returns the delivery id in the mutation.
func (m *OrderMutation) DeliveryID() (id int, exists bool) {
	if m.delivery != nil {
		return *m.delivery, true
	}
	return
}

// DeliveryIDs returns the delivery ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DeliveryID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) DeliveryIDs() (ids []int) {
	if id := m.delivery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDelivery reset all changes of the "delivery" edge.
func (m *OrderMutation) ResetDelivery() {
	m.delivery = nil
	m.cleareddelivery = false
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.orderDate != nil {
		fields = append(fields, order.FieldOrderDate)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldOrderDate:
		return m.OrderDate()
	case order.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldOrderDate:
		return m.OldOrderDate(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDate(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldOrderDate:
		m.ResetOrderDate()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.orderItems != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.delivery != nil {
		edges = append(edges, order.EdgeDelivery)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.orderItems))
		for id := range m.orderItems {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeDelivery:
		if id := m.delivery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorderItems != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorderItems))
		for id := range m.removedorderItems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddelivery {
		edges = append(edges, order.EdgeDelivery)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeDelivery:
		return m.cleareddelivery
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeDelivery:
		m.ClearDelivery()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case order.EdgeDelivery:
		m.ResetDelivery()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderItemMutation represents an operation that mutate the OrderItems
// nodes in the graph.
type OrderItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	orderPrice    *int32
	addorderPrice *int32
	count         *int32
	addcount      *int32
	clearedFields map[string]struct{}
	order         *int
	clearedorder  bool
	done          bool
	oldValue      func(context.Context) (*OrderItem, error)
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows to manage the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for $n.Name.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the id field of the mutation.
func withOrderItemID(id int) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OrderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the OrderItem.
// If the OrderItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the OrderItem.
// If the OrderItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderPrice sets the orderPrice field.
func (m *OrderItemMutation) SetOrderPrice(i int32) {
	m.orderPrice = &i
	m.addorderPrice = nil
}

// OrderPrice returns the orderPrice value in the mutation.
func (m *OrderItemMutation) OrderPrice() (r int32, exists bool) {
	v := m.orderPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderPrice returns the old orderPrice value of the OrderItem.
// If the OrderItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderItemMutation) OldOrderPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderPrice: %w", err)
	}
	return oldValue.OrderPrice, nil
}

// AddOrderPrice adds i to orderPrice.
func (m *OrderItemMutation) AddOrderPrice(i int32) {
	if m.addorderPrice != nil {
		*m.addorderPrice += i
	} else {
		m.addorderPrice = &i
	}
}

// AddedOrderPrice returns the value that was added to the orderPrice field in this mutation.
func (m *OrderItemMutation) AddedOrderPrice() (r int32, exists bool) {
	v := m.addorderPrice
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderPrice reset all changes of the "orderPrice" field.
func (m *OrderItemMutation) ResetOrderPrice() {
	m.orderPrice = nil
	m.addorderPrice = nil
}

// SetCount sets the count field.
func (m *OrderItemMutation) SetCount(i int32) {
	m.count = &i
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *OrderItemMutation) Count() (r int32, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the OrderItem.
// If the OrderItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderItemMutation) OldCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to count.
func (m *OrderItemMutation) AddCount(i int32) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *OrderItemMutation) AddedCount() (r int32, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *OrderItemMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetOrderID sets the order edge to Order by id.
func (m *OrderItemMutation) SetOrderID(id int) {
	m.order = &id
}

// ClearOrder clears the order edge to Order.
func (m *OrderItemMutation) ClearOrder() {
	m.clearedorder = true
}

// OrderCleared returns if the edge order was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.clearedorder
}

// OrderID returns the order id in the mutation.
func (m *OrderItemMutation) OrderID() (id int, exists bool) {
	if m.order != nil {
		return *m.order, true
	}
	return
}

// OrderIDs returns the order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int) {
	if id := m.order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder reset all changes of the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m.order = nil
	m.clearedorder = false
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.orderPrice != nil {
		fields = append(fields, orderitem.FieldOrderPrice)
	}
	if m.count != nil {
		fields = append(fields, orderitem.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldOrderPrice:
		return m.OrderPrice()
	case orderitem.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldOrderPrice:
		return m.OldOrderPrice(ctx)
	case orderitem.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldOrderPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderPrice(v)
		return nil
	case orderitem.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addorderPrice != nil {
		fields = append(fields, orderitem.FieldOrderPrice)
	}
	if m.addcount != nil {
		fields = append(fields, orderitem.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldOrderPrice:
		return m.AddedOrderPrice()
	case orderitem.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldOrderPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderPrice(v)
		return nil
	case orderitem.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldOrderPrice:
		m.ResetOrderPrice()
		return nil
	case orderitem.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m.order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.clearedorder
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}
